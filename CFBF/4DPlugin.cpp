/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : CFBF
 #	author : miyako
 #	2018/05/23
 #
 # --------------------------------------------------------------------------------*/

#include "4DPlugin.h"

#define gdf_already_registed gsf_input_get_type()

void json_set_date(Json::Value& n, GDateTime *dt, const char *date, const char *time, const char *fmt) {

	n[time] = (int)((g_date_time_get_hour(dt) * 3600)
		+ (g_date_time_get_minute(dt) * 60)
		+ (g_date_time_get_second(dt))) * 1000;

	gchar *dateString = g_date_time_format(dt, fmt);

	n[date] = dateString;

#if VERSIONMAC
	if (dateString)
	{
		g_free(dateString);//corrupts heap on windows
	}
#endif

	g_date_time_unref(dt);
}

void addElement(Json::Value& json_element, GsfInput *input, PA_Variable *Param3) {

	PA_long32 i = 0;

	char *name = (char *)gsf_input_name(input);

	GDateTime *modtime = gsf_input_get_modtime(input);
	if (modtime)
	{
		json_set_date(json_element, g_date_time_to_local(modtime), "local_date", "local_time", "%Y-%m-%dT%H:%M:%S%z");
		json_set_date(json_element, g_date_time_to_utc(modtime), "utc_date", "utc_time", "%Y-%m-%dT%H:%M:%SZ");
	}

	size_t size = gsf_input_size(input);

	if (size)
	{
		std::vector<guint8> buf(size);
		guint8 const *p = gsf_input_read(input, size, &buf[0]);

		if (p)
		{
			i = PA_GetArrayNbElements(*Param3);
			PA_ResizeArray(Param3, ++i);
			PA_Variable element = PA_CreateVariable(eVK_Blob);
			PA_SetBlobVariable(&element, (void *)&buf[0], (PA_long32)size);
			PA_SetBlobInArray(*Param3, i, element.uValue.fBlob);
		}

	}

	json_element["name"] = name;
	json_element["size"] = (int)size;
	json_element["data"] = (int)i;
}

void getRoot(Json::Value& json_element, GsfInfile *root, PA_Variable *Param3)
{
	int countChildren = gsf_infile_num_children(root);

	Json::Value children = Json::Value(Json::arrayValue);

	for (int i = 0; i < countChildren; ++i)
	{
		GsfInput *child = gsf_infile_child_by_index(root, i);

		if (child)
		{
			Json::Value json_child_element = Json::Value(Json::objectValue);

			size_t size = gsf_input_size(child);
			if (!size)
			{
				GsfInfile *node = GSF_INFILE(child);
				int countNodeChildren = gsf_infile_num_children(node);
				if (-1 != countNodeChildren)
				{
					char *name = (char *)gsf_input_name(child);

					GDateTime *modtime = gsf_input_get_modtime(child);
					if (modtime)
					{
						json_set_date(json_child_element, g_date_time_to_local(modtime), "local_date", "local_time", "%Y-%m-%dT%H:%M:%S%z");
						json_set_date(json_child_element, g_date_time_to_utc(modtime), "utc_date", "utc_time", "%Y-%m-%dT%H:%M:%SZ");
					}

					json_child_element["name"] = name;
					json_child_element["size"] = (int)size;

					/* recursive call */
					getRoot(json_child_element, node, Param3);
					children.append(json_child_element);
				}
				else
				{
					/* leaf with no data */
					addElement(json_child_element, child, Param3);
					children.append(json_child_element);
				}
		}
			else
			{
				/* leaf with data */
				addElement(json_child_element, child, Param3);
				children.append(json_child_element);
			}

			g_object_unref(child);
		}
	}

	json_element["storages"] = children;
}

#pragma mark Startup / Exit

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

#if VERSIONWIN

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	glib_DllMain(hinstDLL, fdwReason, lpvReserved);
	gio_DllMain(hinstDLL, fdwReason, lpvReserved);
	gobject_DllMain(hinstDLL, fdwReason, lpvReserved);
	gsf_DllMain(hinstDLL, fdwReason, lpvReserved);
	
	return TRUE;
}

#endif

void OnExit()
{
    if(gdf_already_registed) {
        gsf_shutdown();
    }
}

void OnStartup()
{
    
    if(gdf_already_registed){
        
        gsf_init();
        
    }
    
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		
		switch(pProcNum)
		{
			case kInitPlugin :
			case kServerInitPlugin :
				OnStartup();
				break;

            case kDeinitPlugin :
            case kServerDeinitPlugin:
                OnExit();
                break;
				
			case 1 :
				CFBF_PARSE_DATA(params);
				break;
				
		}
	}
	catch(...)
	{
		
	}
}

#pragma mark -

// ------------------------------------- CFBF -------------------------------------

#pragma mark -

static void json_set_text_param(Json::Value& n, C_TEXT& t) {

	Json::StreamWriterBuilder writer;
	writer["indentation"] = "";

	std::string json = Json::writeString(writer, n);

	t.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.length());
}

void CFBF_PARSE_DATA(PA_PluginParameters params) {

	PackagePtr pParams = (PackagePtr)params->fParameters;

	C_TEXT Param2;

	PA_Variable Param3 = PA_CreateVariable(eVK_ArrayBlob);
	PA_Handle h = *(PA_Handle *)(pParams[0]);

	if (h)
	{
		Json::Value json = Json::Value(Json::objectValue);

		if (gdf_already_registed) {

			GsfInput *input = gsf_input_memory_new((const guint8 *)PA_LockHandle(h),
				PA_GetHandleSize(h), false);

			//            GType type = g_type_from_name("GsfInput");

			if (input)
			{
				input = gsf_input_uncompress(input);

				GError *err = NULL;
				GsfInfile *root = gsf_infile_msole_new(input, &err);

				if (!root)
				{
					json["error"] = (char *)err->message;
				}
				else
				{
					getRoot(json, root, &Param3);

					g_object_unref(root);
				}
				g_object_unref(input);
			}

		}
		else {

			/* plugin was reloaded; g_type_register_static does not work this way */

		}

		json_set_text_param(json, Param2);

		PA_UnlockHandle(h);
	}

	PA_SetVariableParameter(params, 3, Param3, 0);
	Param2.toParamAtIndex(pParams, 2);

}
